/*
 * File: AcdiVocaMessage.java
 * 
 * Copyright (C) 2011 The Humanitarian FOSS Project (http://www.hfoss.org)
 * 
 * This file is part of the ACDI/VOCA plugin for POSIT, Portable Open Search 
 * and Identification Tool.
 *
 * This plugin is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License (LGPL) as published 
 * by the Free Software Foundation; either version 3.0 of the License, or (at
 * your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, 
 * but WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU LGPL along with this program; 
 * if not visit http://www.gnu.org/licenses/lgpl.html.
 * 
 */

package org.hfoss.posit.android.plugin.acdivoca;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import com.j256.ormlite.dao.Dao;
import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.stmt.DeleteBuilder;
import com.j256.ormlite.stmt.PreparedQuery;
import com.j256.ormlite.stmt.QueryBuilder;
import com.j256.ormlite.stmt.Where;
import com.j256.ormlite.support.ConnectionSource;
import com.j256.ormlite.table.TableUtils;

import android.util.Log;

public class AcdiVocaMessage {
	
	public static final String TAG = "AcdiVocaMessage";
	
	public static final String ACDI_VOCA_PREFIX = "AV";
	public static final String ACK = "ACK";
	public static final String IDS = "IDS";
	public static final boolean EXISTING = true;
	
	
	/**
	 * For the message table.
	 */
	public static final String MESSAGE_TABLE = "sms_message_log";
	public static final String MESSAGE_ID = "_id";
	public static final int UNKNOWN_ID = -9999;
	public static final String MESSAGE_BENEFICIARY_ID = AttributeManager.MESSAGE_BENEFICIARY_ID;  // Row Id in Beneficiary table
	public static final String MESSAGE_TEXT = AttributeManager.MESSAGE_TEXT;
	public static final String MESSAGE_STATUS = AcdiVocaFind.MESSAGE_STATUS; 
	public static final String[] MESSAGE_STATUS_STRINGS = {"Unsent", "Pending", "Sent", "Ack", "Deleted"};
	public static final int MESSAGE_STATUS_UNSENT = 0;
	public static final int MESSAGE_STATUS_PENDING = 1;
	public static final int MESSAGE_STATUS_SENT = 2;
	public static final int MESSAGE_STATUS_ACK = 3;
	public static final int MESSAGE_STATUS_DEL = 4;
	public static final String MESSAGE_CREATED_AT = AttributeManager.MESSAGE_CREATED_AT;
	public static final String MESSAGE_SENT_AT = AttributeManager.MESSAGE_SENT_AT;
	public static final String MESSAGE_ACK_AT = AttributeManager.MESSAGE_ACK_AT;

	

	// id is generated by the database and set on the object automagically
	@DatabaseField(generatedId = true)  int id;        // row_id in message table, generated automatically
	@DatabaseField(columnName = MESSAGE_ID) int messageId = UNKNOWN_ID;    // row Id of message in our Db
	@DatabaseField int beneficiaryId;         // row Id of beneficiary in our Db
	@DatabaseField String smsMessage;         // abbreviated Attr/val pairs
	@DatabaseField(columnName = MESSAGE_STATUS) int msgStatus = -1;
	@DatabaseField Date message_created_at;
	@DatabaseField Date message_sent_at;
	@DatabaseField Date message_ack_at;
	
	private String rawMessage;	     // Attr/val pairs with long attribute names
	private String msgHeader =""; 
	private boolean existing = !EXISTING;  // Built from an existing message or, eg, a PENDING)
	private String numberSlashBatchSize;   // e.g 1/10  -- i.e., 1st of 10 messages in this batch
	
	public AcdiVocaMessage() {
		// Needed for ormlite
	}
	
	public AcdiVocaMessage(int messageId, int beneficiaryId, int msgStatus,  
			String rawMessage, String smsMessage, String msgHeader, boolean existing) {
		super();
		this.messageId = messageId;
		this.beneficiaryId = beneficiaryId;
		this.msgStatus = msgStatus;
		this.rawMessage = rawMessage;
		this.smsMessage = smsMessage;
		this.msgHeader = msgHeader;
		this.existing = existing;
	}
	
	/**
	 * Construct an instance from an Sms Message. This should be the
	 * converse of the toString() method, which returns this object as
	 * an Sms message. 
	 * @param smsText a string of the form AV=msgid,....  where the ...
	 * is either a comma-separated list of attr=val pairs or the ...
	 * is an ampersand separated list of Ids.  
	 * The message has the form:
	 * 
	 * 	AV=id,M:N,mi=mid,a1=v1,a2=v2,...
	 *
	 */
	public AcdiVocaMessage(String smsText) {
		Log.i(TAG, "Creating from smstext:" + smsText);
		String[] msgparts = smsText.split(AttributeManager.PAIRS_SEPARATOR);
//		for (int k = 0; k < msgparts.length; k++) {
//			Log.i(TAG, "msgpart " + k + " :" + msgparts[k]);
//		}
		String[] firstPair = msgparts[0].split(AttributeManager.ATTR_VAL_SEPARATOR);  // AV=id
		String[] thirdPair = msgparts[2].split(AttributeManager.ATTR_VAL_SEPARATOR);  // mi=mid
		String avIdStr = firstPair[1];
		int avId = Integer.parseInt(avIdStr);
		String msgIdStr = thirdPair[1];
		int msgId = Integer.parseInt(msgIdStr);
		smsMessage = "";
		if (avId < 0 && avId != UNKNOWN_ID) {
			messageId = avId * -1;
			beneficiaryId =  UNKNOWN_ID;
			existing = true;
		} else {
			beneficiaryId = avId;
//			messageId =  AcdiVocaDbHelper.UNKNOWN_ID;
			messageId =  msgId;
			existing = true;
		} 
		
		// NOTE: We skip the first 3 pairs in constructing the actual SMS 
		// that was sent.  The first three pairs represent PREFIX information,
		// namely, AV=mid,N:m,mi=msgid ...
		//
		for (int k = 3; k < msgparts.length; k++) {
//			Log.i(TAG, "msgpart " + k + " :" + msgparts[k]);
			smsMessage += msgparts[k] + AttributeManager.PAIRS_SEPARATOR;
		}
		Log.i(TAG, "Resulting sms :" + smsMessage);
	}
	
	
	public static void createTable(ConnectionSource connectionSource) {
		try {
			TableUtils.createTable(connectionSource, AcdiVocaMessage.class);
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
	
	/**
	 * Deletes all rows from the Beneficiary Table.
	 * @return
	 */
	public static int clearTable(Dao<AcdiVocaMessage, Integer> dao) {
		Log.i(TAG, "Clearing Message Table");
		int count = 0;
		try {
			DeleteBuilder<AcdiVocaMessage, Integer> deleteBuilder = dao.deleteBuilder();
			// Delete all rows -- no where clause
			count = dao.delete(deleteBuilder.prepare());
		} catch (SQLException e) {
			Log.e(TAG, "SQL Exception " + e.getMessage());
			e.printStackTrace();
		}
		return count;
	}
	
	/**
	 * Creates a new entry in the message table and update the FINDS
	 * table to point to the message.
	 * @return
	 */
	public static int createMessage (Dao<AcdiVocaMessage, Integer> daoMsg, 
			Dao<AcdiVocaFind, Integer> daoFind, 
			AcdiVocaMessage acdiVocaMsg, int beneficiary_id, int msgStatus) {
		Log.i(TAG, "Creating message for beneficiary = " + beneficiary_id + " status= " + msgStatus);

		Date now = new Date(System.currentTimeMillis());

		int rows = 0;
		try {
			acdiVocaMsg.message_created_at = now;
			rows = daoMsg.create(acdiVocaMsg);
		} catch (SQLException e) {
			Log.e(TAG, "SQL Exception " + e.getMessage());
			e.printStackTrace();
		}
		
		if (rows != 1) {
			Log.i(TAG, "Unable to insert NEW message for beneficiary id= " + beneficiary_id);
		} else {
			Log.i(TAG, "Inserted NEW message, id= " + acdiVocaMsg.id + " bene_id=" + beneficiary_id); 
			
			boolean success = false;
//			try {
				success = AcdiVocaFind.updateMessageStatus(daoFind, beneficiary_id, acdiVocaMsg.id, msgStatus);
//			} catch (SQLException e) {
//				// TODO Auto-generated catch block
//				e.printStackTrace();
//			}
//			if (!updateBeneficiaryMessageStatus(beneficiary_id, acdiVocaMsg.id, msgStatus))
			if (success)
				Log.i(TAG, "Updated beneficiary id = " + beneficiary_id + " for message " + acdiVocaMsg.id);
			else
				Log.e(TAG, "Unable to update beneficiary id = " + beneficiary_id + " for message " + acdiVocaMsg.id);
		} 
		return acdiVocaMsg.id;  // Return the message Id.
	}

	
//	/**
//	 * Retrieves  messages by status. 
//	 * @param statusFilter
//	 * @param order_by
//	 * @return
//	 */
//	public static List<AcdiVocaMessage> fetchAllByStatus(Dao<AcdiVocaMessage, Integer> dao, int statusFilter) {
//		int msg_status = mapSearchFilterToMessageStatus (statusFilter);
//
//		List<AcdiVocaMessage> list = null;
//		AcdiVocaMessage avMsg = null;
//		try {
//			QueryBuilder<AcdiVocaMessage, Integer> queryBuilder = dao.queryBuilder();
//			if (msg_status != 0) {
//				Where<AcdiVocaMessage, Integer> where = queryBuilder.where();
////				where.eq("msgStatus", msg_status);
//				where.eq(MESSAGE_STATUS, msg_status);
//			}
//			PreparedQuery<AcdiVocaMessage> preparedQuery = queryBuilder.prepare();
//			list = dao.query(preparedQuery);
//		} catch (SQLException e) {
//			Log.e(TAG, "SQL Exception " + e.getMessage());
//			e.printStackTrace();
//		}
//		return list;
//	}
	
	/**
	 * Helper method to map search filter constant to message status constant.
	 */
	private static int mapSearchFilterToMessageStatus (int searchFilter) {
		switch (searchFilter) {
		case SearchFilterActivity.RESULT_SELECT_PENDING:
			return AcdiVocaMessage.MESSAGE_STATUS_PENDING;
		case SearchFilterActivity.RESULT_SELECT_SENT:
			return AcdiVocaMessage.MESSAGE_STATUS_SENT;
		case SearchFilterActivity.RESULT_SELECT_ACKNOWLEDGED:
			return AcdiVocaMessage.MESSAGE_STATUS_ACK;
		default:
			return AcdiVocaMessage.MESSAGE_STATUS_UNSENT;
		}
	}
	
	
	/**
	 * Retrieves a Message object by its Id
	 * @return
	 */
	public static AcdiVocaMessage fetchById (Dao<AcdiVocaMessage, Integer> dao, int msgId) {		
		Log.i(TAG, "Fetching message for id = " + msgId);
		AcdiVocaMessage avMsg = null;
		try {
			avMsg = dao.queryForId(msgId);
		} catch (SQLException e) {
			Log.e(TAG, "SQL Exception " + e.getMessage());
			e.printStackTrace();
		}
		return avMsg;
	}
	
	/** 
	 * Returns an ArrayList of Messages.
	 * @param statusFilter an int that selects messages by status
	 * @return an array of SMS strings
	 */
	public static ArrayList<AcdiVocaMessage> fetchAllByStatus(Dao<AcdiVocaMessage, Integer> dao, int statusFilter) {
		int msg_status = mapSearchFilterToMessageStatus (statusFilter);
		
		List<AcdiVocaMessage> list = null;
		AcdiVocaMessage avMsg = null;
		try {
			QueryBuilder<AcdiVocaMessage, Integer> queryBuilder = dao.queryBuilder();
			if (msg_status != 0) {
				Where<AcdiVocaMessage, Integer> where = queryBuilder.where();
//				where.eq("msgStatus", msg_status);
				where.eq(MESSAGE_STATUS, msg_status);
			}
			PreparedQuery<AcdiVocaMessage> preparedQuery = queryBuilder.prepare();
			list = dao.query(preparedQuery);
		} catch (SQLException e) {
			Log.e(TAG, "SQL Exception " + e.getMessage());
			e.printStackTrace();
		}

		ArrayList<AcdiVocaMessage> acdiVocaMsgs =  new ArrayList<AcdiVocaMessage>();

		// Create an ArrayList that adds message header messages.
		Iterator<AcdiVocaMessage> it = list.iterator();
		while (it.hasNext()) {
			AcdiVocaMessage msg = it.next();
			String header = "MsgId:" + msg.id + " Stat:" + msg.msgStatus + " Len:" 
				+ msg.smsMessage.length() + " Bid = " + msg.beneficiaryId;
			msg.setMsgHeader(header);
			acdiVocaMsgs.add(msg);
		}
		
		return acdiVocaMsgs;
	}
	
	
	/**
	 * Updates the message table for an existing message.
	 * @return
	 */
	public static boolean updateStatus(Dao<AcdiVocaMessage, Integer> dao, int beneficiary_id, int msg_id, int status ) {
		Log.i(TAG, "Updating message, bene_id = " + beneficiary_id + " message = " + msg_id + " status=" + status);

		int result = 0;
		Date now = new Date(System.currentTimeMillis());
//		String now = new Date(System.currentTimeMillis()).toString()
//		+ " " + new Time(System.currentTimeMillis()).toString();
		Log.i(TAG, "Time now = " + now);
		
		AcdiVocaMessage avMsg = null;
		try {
			avMsg = dao.queryForId(msg_id);  // Retrieve the message
			if (avMsg != null) {
				avMsg.setMsgStatus(status);
				avMsg.setBeneficiaryId(beneficiary_id);
				if (status == AcdiVocaMessage.MESSAGE_STATUS_SENT) {
					avMsg.message_sent_at = now;
				} else if (status == AcdiVocaMessage.MESSAGE_STATUS_ACK) 
					avMsg.message_ack_at = now;
				result = dao.update(avMsg);  // And update
			} else {
				Log.e(TAG, "Unable to retrieve message id = " + msg_id ); 	
			}
		} catch (SQLException e) {
			Log.e(TAG, "SQL Exception " + e.getMessage());
			e.printStackTrace();
		}
		if (result == 1) 
			Log.d(TAG, "Updated message id = " + msg_id + " for message " + msg_id + " status=" + status);
		return result == 1;
	}	

	
//	/**
//	 * Updates the message status in the message table and Finds table for
//	 * distribution update messages.  In this case the msg_id is UNKNOWN and
//	 * the beneficiary is KNOWN.
//	 * @param message the SMS message
//	 * @param status the new status
//	 * @return
//	 */
//	public static boolean updateMessageStatusForNonBulkMessage(Dao<AcdiVocaMessage, Integer> dao, AcdiVocaMessage acdiVocaMsg, int status) {
//		Log.i(TAG, "Updating, msg_id " + acdiVocaMsg.getMessageId() + 
//				" bene_id = " + acdiVocaMsg.getBeneficiaryId() + " to status = " + status);
//		
////		int beneficiary_id = acdiVocaMsg.getBeneficiaryId();
////		int msg_id = acdiVocaMsg.getMessageId();
////		
//		boolean result = false;
////		
////		try {
////			Dao<AcdiVocaFind, Integer> dao = getAcdiVocaFindDao();
////			AcdiVocaFind avFind = dao.queryForId(beneficiary_id);
////			if (avFind != null) {
////				avFind.message_status = status;
////				avFind.message_id = msg_id;
////				int rows = dao.update(avFind);
////				result = rows == 1;
////			}
////		} catch (SQLException e) {
////			// TODO Auto-generated catch block
////			e.printStackTrace();
////		}
//
////		if (result) {
////			result = updateMessageStatus(beneficiary_id, msg_id, status);
//			try {
//				result = AcdiVocaMessage.updateStatus(getAcdiVocaMessageDao(), beneficiary_id, msg_id, status);
//			} catch (SQLException e) {
//				// TODO Auto-generated catch block
//				e.printStackTrace();
//			}
////		}
//		return result;
//	}
	
	
	public int getMessageId() {
		return messageId;
	}

	public void setMessageId(int messageId) {
		this.messageId = messageId;
	}

	public int getBeneficiaryId() {
		return beneficiaryId;
	}

	public void setBeneficiaryId(int beneficiaryId) {
		this.beneficiaryId = beneficiaryId;
	}

	
	public int getMsgStatus() {
		return msgStatus;
	}

	public void setMsgStatus(int msgStatus) {
		this.msgStatus = msgStatus;
	}

	public String getRawMessage() {
		return rawMessage;
	}

	public void setRawMessage(String rawMessage) {
		this.rawMessage = rawMessage;
	}

	public String getSmsMessage() {
		return smsMessage;
	}

	public void setSmsMessage(String smsMessage) {
		this.smsMessage = smsMessage;
	}

	public String getMsgHeader() {
		return msgHeader;
	}

	public void setMsgHeader(String msgHeader) {
		this.msgHeader = msgHeader;
	}
	
	public boolean isExisting() {
		return existing;
	}

	public void setExisting(boolean existing) {
		this.existing = existing;
	}
	
	

	public String getNumberSlashBatchSize() {
		return numberSlashBatchSize;
	}

	public void setNumberSlashBatchSize(String numberSlashBatchSize) {
		this.numberSlashBatchSize = numberSlashBatchSize;
	}

	/**
	 * Return an Sms Message.  The message has the following format:
	 * 		AV=id,M:N,mi=mid,a1=v1,a2=v2,...
	 * where id is either the message message ID or the beneficiary ID and
	 * where mid is the message ID.  So in some cases id=mid.
	 */
	@Override
	public String toString() {
		String message;
		if (beneficiaryId != UNKNOWN_ID) {
			message = 
				AcdiVocaMessage.ACDI_VOCA_PREFIX 
			+ AttributeManager.ATTR_VAL_SEPARATOR 
			+ getBeneficiaryId() // For normal messages we use the beneficiary's row id, 1...N
			+ AttributeManager.PAIRS_SEPARATOR
			+ AttributeManager.ABBREV_MSG_NUMBER_SLASH_SIZE
			+ AttributeManager.ATTR_VAL_SEPARATOR
			+ getNumberSlashBatchSize()
			+ AttributeManager.PAIRS_SEPARATOR
			+ AttributeManager.ABBREV_MESSAGE_ID
			+ AttributeManager.ATTR_VAL_SEPARATOR 
			+ messageId 
			+ AttributeManager.PAIRS_SEPARATOR
			+ getSmsMessage();
		} else {
			message = 
				AcdiVocaMessage.ACDI_VOCA_PREFIX 
			+ AttributeManager.ATTR_VAL_SEPARATOR 
			+ getMessageId() * -1   // For Bulk messages we use minus the message id (e.g., -123)
			+ AttributeManager.PAIRS_SEPARATOR
			+ AttributeManager.ABBREV_MSG_NUMBER_SLASH_SIZE
			+ AttributeManager.ATTR_VAL_SEPARATOR
			+ getNumberSlashBatchSize()
			+ AttributeManager.PAIRS_SEPARATOR
			+ AttributeManager.ABBREV_MESSAGE_ID
			+ AttributeManager.ATTR_VAL_SEPARATOR 
			+ messageId 
			+ AttributeManager.PAIRS_SEPARATOR
			+ getSmsMessage();
		}
		return message;
		//return msgHeader + AttributeManager.PAIRS_SEPARATOR + smsMessage;
	}
}
